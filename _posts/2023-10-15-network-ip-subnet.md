---
title: IP 주소와 서브넷
author: 노아
date: 2023-10-15 23:49:00 +0800
categories: [Network, IP 주소와 서브넷]
tags: [네트워크, ip, subnet, network]
pin: true
math: true
mermaid: true

---
IP 주소와 서브넷


**통신방식**

그러면, ip 주소와 서브넷에 대해 알아보기 전에 유니캐스트, 멀티캐스트 등에 대해 알아보자. 이는 네트워크에서 출발지에서 목적지로 데이터를 전송할때 다음의 통신 방식을 사용한다.

- 유니캐스트
  - 1:1 통신
  - 출발지와 목적지가 1:1 통신

- 브로드캐스트
  - 1:모든 통신
  - 동일 네트워크에 존재하는 모든 호스트가 목적지

- 멀티캐스트
  - 1:그룹 (멀티캐스트 구독 호스트) 통신
  - 하나의 출발지에서 다수의 특정 목적지로 데이터 전송

- 애니캐스트
  - 1:1 통신 (목적지는 동일 그룹 내의 1개 호스트)
  - 다수의 동일 그룹 중 가장 가까운 호스트에서 응답
  - IPv4에서는 일부 기능 구현, IPv6은 모두 구현 가능



| 타입      | 통신 대상 | 범위     | IPv4 | IPv6 | 예제
|:----------|:---------|--------:|----- :|----:|--------:|
| 유니캐스트 | 1:1 | 전체 네트워크 | o     | o   | HTTP    |
| 브로드캐스트 | 1:all | 서브넷(로컬 네트워크) | o     | x   | ARP    |
| 멀티캐스트 | 1:그룹 | 정의된 구간 | o     | o   | 방송    |
| 애니캐스트 | 1:1 | 전체 네트워크 | △     | o   | 6 to 4, DNS    |



---
**MAC 주소**

그 다음에는 MAC 주소에 대해 알아보자. MAC 주소에 대해 아래와 같이 정의를 내릴 수 있다.

> MAC, "Media Access Control의 줄임말로 2계층에서 통신을 위해 네트워크 인터페이스에 할당된 고유 식별자.

즉, 네트워크에 접속하는 모든 장비의 물리적인 주소를 MAC 주소라고 하며, 이 주소를 이용해 서로 통신이 이루어진다. 이 번호는 변경할 수 없도록 하드웨어에 고정되어 출하되므로 네트워크 구성 요소마다 다른 주소를 가지고 있다. 즉, MAC 주소는 주민등록증과 같이 장치마다 고유 특징이 있다. 이러한 MAC 주소는 IEEE와 제조사가 각각 24비트씩 값을 할당하여 MAC 주소를 생성한다. 이에 대한 원리는 다음과 같다.

![Desktop View](/assets/img/network/ip/mac_address_system.png){: width="972" height="589" .w-50}

OUI : IEEE가 제조사에 할당하는 부분.
UAA : 각 제조사에서 네트워크 구성 요소에 할당하는 부분.

MAC 주소는 48비트로 되어있는데, 앞의 24비트는 OUI, 뒤의 24비트는 UAA라고 기억해두자. 그리고 OUI, UAA 각각에 대한 설명은 아래와 같다.

> OUI : OUI 또는 제조업체 고유 식별자로써, IEEE가 제조사에 할당하는 부분으로, 네트워크 장치를 제조한 회사를 식별하는데 사용됨.<br>
UAA : 제조업체가 할당한 고유 번호로, 해당 제조업체의 각 NIC에 대한 고유 식별자. 즉, 각 제조사에서 네트워크 구성 요소에 임의로 할당하는 부분.

이런 원리로 생성된 MAC 주소는 물리 계층에서 전기 신호로 보내진 데이터 전송에 대해 데이터의 작은 조각인 패킷으로 바뀌어진 상황 중 데이터 전송을 하는 과정에서 우편 번호와도 같은 역할을 한다고 보면 될 거 같다. 데이터 전송은 패킷으로 이루어지는데, 로컬 네트워크 상에서 출발지 MAC 주소에서 스위치를 통해 목적지 MAC 주소로 전송됨을 원칙으로 한다. 이를 OSI 2계층인 데이터 링크 계층이라 불리며. 이 계층에서 MAC 주소는 중요하다고 할 수 있다. 

그런데, 여기서 만약에 목적지 MAC 주소가 로컬 네트워크가 아닌 다른 네트워크에 있다면? 바로 이때! 2계층인 데이터 링크 계층에서 3계층인 네트워크 계층으로 나아가게 되고, 이 계층에서 데이터 전송은 MAC 주소를 통해서가 아닌, 라우팅을 통한 데이터 전송이 이루어지게 된다. 그리고 데이터 링크 계층에서는 MAC 주소를 통해 진행되었다면, 네트워크 계층에서는 IP 주소 형태로 통신을 주고 받게 된다.

각 디바이스 장치들마다 MAC 주소는 존재하는 반면, 통신이 이루어지는 디바이스에 한해서는 ip 주소 형태를 통해야 하는 특성 탓에 같은 네트워크 하에서의 통신이라면 MAC 주소를 통한, 데이터 링크 계층을 통해 이루어지게 되는 것이다. 반면, 서로 다른 네트워크 하에서의 통신이라면 ip 주소를 통한, 네트워크 계층을 통해 이루어지게 된다. 

---
**IP**

그러면 이제 IP에 대해 본격적으로 알아볼까?

다음은 IP 주소(IP1, IP2, IP3)를 가진 세 개의 송신자가 가로로 나열된 형태로 라우터(R)를 통해 세 개의 수신자(IP4, IP5, IP6)로 데이터를 보내고 받는 과정을 나타내는 다이어그램을 나타낸 것이다. 다이어그램은 mermaid 코드를 통해 구현해보았다.

![Desktop View](/assets/img/network/ip/ip_diagram_1.png){: width="972" height="589" }

위 다이어그램은 IP에 대해 어떤 식으로 진행되는지를 잘 나타내는 내용이라 할 수 있어서 이 다이어그램을 들고 나와 보았다. 

IP는 IPv4와 IPv6로 구성되어있으며, IPv4에서는 클래스풀과 클래스리스 방식이 존재한다. 또한, 공인 IP, 사설 IP 개념이 이 과정에서 나타나게 되는데. 먼저 IP의 기초 개념들을 설명한 뒤, IPv4에 대한 소개와 함께 클래스풀과 클래스리스 방식에 대해 살펴본 후, IPv6 방식에 대해 간단히 소개하고 공인 IP, 사설 IP 개념을 다루면서 IP 주소와 서브넷 포스팅을 마칠까 한다.

그러면 먼저 IP에 대해 알아보자. IP란 무엇일까? IP는 111.222.333.444 같은 패턴으로 이루어져 있는 고유의 번호 체계로써 지구상 존재하는, 통신이 가능한 디바이스마다 고유의 번호로 가지고 있다. 여기서 네트워크 하드웨어인 경우에 MAC 주소도 함께 가지고 있는 것이고. 즉, IP는 통신이 가능한 디바이스마다 고유의 값으로 이러한 IP를 가진 기기를 호스트라고 한다.

이런 측면에서 보자면, 정보를 주고 받으면서 우리가 인터넷을 통해 홈페이지에 접속해서 정보를 얻고 요청하는 모든 과정은 결국 다음과 같다고 할 수 있다.

> 저마다의 고유한 id와도 같은 IP를 가진 호스트끼리 통신을 통해 데이터를 주고 받는 과정.

A라는 사람이 B라는 사람에게 편지를 부치고 싶다고 해보자. 이때, A라는 사람은 편지를 우체국을 통해 B라는 사람에게 자신이 쓴 편지를 갈 수 있도록 할 것이다. 여기서 A라는 사람은 출발지 MAC 주소, 출발 IP이고. B라는 사람은 목적지 MAC 주소, 목적 IP이고. 편지는 데이터, 우체국은 라우팅에 비유할 수 있다.

A라는 사람과 B라는 사람이 같은 마을에 살고 있다고 해보자. 그러면 비단 우체국을 통하지 않고서라도 편지를 수월하게 전해줄 수 있을 것이다. 그러나, 만약 둘이 서로 다른 마을에 산다면? 다른 나라에 살고 있다면? 그때는 편지를 어떻게 부칠 것인가? 이럴 경우 우체국을 통해서 편지를 부칠 수 밖에 없다. 이럴 때 라우팅 역할을 하는 우체국을 통해 부치게 된다. 이러한 이유로 앞에서 서술했듯이, 서로 같은 네트워크 상에서의 통신이라면 데이터 링크 계층 내에서 움직이지만, 서로 다른 네트워크 상에서의 통신이라면 데이터 링크 계층이 아닌, 네트워크 계층으로 라우팅을 통해 통신이 이루어진다고 설명했던 것이다.

다이어그램으로 그려보면 다음과 같다.

![Desktop View](/assets/img/network/ip/ip_diagram_2.png){: width="972" height="589" }

그렇다면, 이러한 IP 주소 체계는 어떻게 될까?

![Desktop View](/assets/img/network/ip/ipv4_address_system.png){: width="972" height="589"}

앞서서 IP는 IPv4와 IPv6로 구성되어있다고 설명했다. 그렇다. IP는 IPv4와 IPv6로 구성되어있는데, 우리가 쓰는 건 IPv4 방식으로 되어있다. 그러나 Ipv4 방식에 한계가 있기 때문에 그에 대한 대안으로 나온 방식이 IPv6인데 왜 IPv6를 IPv4에 대한 대안이라고 말하는지는 이 주소 체계를 보면 알 수 있다. 본 포스팅에서는 IPv4 방식만 설명할 것이며, IPv6는 추후에 공부해서 정리할 예정이다.

IP주소는 4개의 옥텟이라 부르는 8비트 단위로 나뉘며, 각 옥텟은 "."으로 구분한다. IP는 10진수로 표현하지만, 이 10진수는 그 아래 조그맣게 적혀있는 이진수를 10진수로 바꿔서 나타낸 것이다. 

---
**네트워크 주소, 호스트 주소**

이러한 IP 주소는 네트워크 주소와 호스트 주소 두 부분으로 나뉘며, 이때 이 둘을 구분하는 경계점은 고정되어 있지 않다. 그렇기에 클래스풀 방식이나 클래스리스 방식을 도입하여 네트워크 주소와 호스트 주소를 나누며, 호스트 주소를 가지는 체계를 도입하였다. 이는 설명할 것이다. 그러면, 먼저 네트워크 주소와 호스트 주소 각각에 대해 알아보자.

여러 책에서는 네트워크 주소와 호스트 주소에 대해 이렇게 설명한다.

> 네트워크 주소 : 호스트들을 모은 네트워크를 지칭하는 주소. 네트워크 주소가 동일한 네트워크를 로컬 네트워크라고 함.<br>
호스트 주소 : 하나의 네트워크 내에 존재하는 호스트들을 구분하기 위한 주소.

위 개념이 이해하기 힘들다면, 이 그림을 보면서 이해해보면 쉽게 이해할 수 있을 것이다.

![Desktop View](/assets/img/network/ip/ip_understand_total.png){: width="972" height="589"}

마스터링 TCP/IP 입문편(성안당 출판) 책에 존재하는 그림인데, 이 그림을 통해 네트워크 주소와 호스트 주소 뿐만 아니라 IP에 대한 이해를 할 수 있는 자료로 판단하여 가지고 와보았다.

예를 들어 A라는 회사가 있고. 그 회사에서 회사 사설 IP로 192.168.77.4와 192.168.77.8 이렇게 두 개가 있다고 해보자. 그러면, 여기서 A라는 회사는 아래의 IP 주소를 가지고 있는 것이다.

192.168.77.4
192.168.77.8

여기서 192.168.77까지는 동일한데, 마지막 네자리수가 다르다!!! 왜냐하면, 앞 세자리까지는 네트워크 주소로서 두 서버가 동일 네트워크를 사용하고 있기 때문에 앞 세자리는 같은데. 뒤 네자리수의 경우, 서로 다른 서버이기 때문에 각기 고유한 호스트 주소를 가지고 있는 셈이다. 

이렇게 IP는 네트워크 주소와 호스트 주소 이렇게 두 개로 이루어져 있는데. 이게 앞의 1자리 수만 네트워크 주소일 수도 있고. 앞의 2자리수까지만 네트워크 주소이고 그 이하가 호스트 주소일 수 있는 등 다양하게 존재한다. 그리고 여기서 이 네트워크 주소와 호스트 주소를 구분하는 구분자를 "서브넷 마스크"라고 하는 것이고. 그러면 다시 이어서 IP에 대해 알아보면.

IP는 8비트가 4개의 옥텟으로 구성되어 있으며, 각 비트가 이진수로써 각 소속된 옥텟 하나를 구성하는 단위로 존재한다. 이를 통해 IP 주소로 표현할 수 있는 조합 가능한 수를 계산하면 다음과 같다.

$2^{32} = 4,294,967,296$

---
**클래스풀, 클래스리스 방식**

여기서 IP 주소를 네트워크 주소와 호스트 주소로 나누고 하다보면, IP 주소를 할당할 컴퓨터의 수는 적다. 그렇다면 이러한 IP 주소를 어떻게 어떤 방식으로 나눠서 할당할까? 그에 대한 방식으로 두가지가 존재한다. 클래스풀과 클래스리스 방식인데, 먼저 클래스풀 방식부터 알아보자.

그림으로 나타내보면 아래와 같다.

![Desktop View](/assets/img/network/ip/classpol_pic.jpg){: width="972" height="589"}

각 8비트씩 한 옥텟 단위마다 존재하는 값이 이진수로 나타냈을때를 기준으로 생각하면, 이 클래스풀 방식을 이해하기 쉽다.

먼저, 클래스 A부터 설명해보자면, IP 주소의 맨 앞 1비트가 0으로 시작하는 경우로, IP 주소의 맨 앞 8비트까지가 네트워크 주소가 되며 그 이하는 호스트 주소가 된다.

그러므로 비트를 이진수를 기준으로 계산해보면,

00000000 ~ 01111111까지이고, 이를 십진수로 환산하면, 아래에 나와있는 범위까지 클래스 A로 IP 주소를 할당할 수 있음을 알 수 있다.

0.0.0.0 ~ 127.0.0.0

이에 따라 한 네트워크 안에서 할당할 수 있는 호스트 주소는 16,777,214개가 된다.

클래스 B는 IP 주소의 맨 앞 2비트가 10으로 시작하는 경우로 IP 주소의 맨 앞 16비트까지가 네트워크 주소가 된다. 이에 따라 128.0.0.0 ~ 191.255.0.0까지가 클래스 B의 네트워크 주소가 되며, 한 네트워크 안에서 할당할 수 있는 호스트 주소는 65,534개가 된다. 

클래스 C는 IP 주소의 맨 앞 3비트가 110으로 시작하는 경우로, IP 주소의 맨 앞 24비트까지가 네트워크 주소가 되며, 하위 8비트는 호스트 주소로 할당된다. 이에 따라 한 네트워크 안에서 할당할 수 있는 호스트 주소는 254개가 된다. 

클래스 D는 IP 주소의 맨 앞 4비트가 1110으로 시작하는 경우로, IP 주소의 맨 앞 32비트까지가 네트워크 주소가 된다. 클래스 D는 호스트 주소 부분이 없으며, IP 멀티캐스트 통신에 사용된다.

여기서 의문점이 있을 것이다. 계산해보면, 각각의 한 네트워크 안에서 할당할 수 있는 호스트 주소로 각각 2개씩이 빠진 것을 알 수 있다. 일례로 클래스 C를 생각해보자. 하위 8비트가 호스트 주소로 할당된다고 했으니, 계산해보면 2의 8승 = 256개여야 하는데, 왜 254개라고 했을까? 이는 호스트 주소를 비트로 나타낼 때에 모든 비트를 0으로 하거나 모든 비트를 1로 할 수 없다는 점 때문이다.

호스트 주소의 모든 비트가 0인 주소는 네트워크 주소를 나타내는 경우나 IP 주소를 모르는 경우에 사용하도록 되어있기 때문에 일반적으로 사용할 수 없으며, 호스트의 모든 비트가 1인 주소는 브로드캐스트 주소로 사용된다. 그래서 각 IP 주소의 호스트 주소에서 할당할 수 있는 수는 이 두 값을 뺀 수가 된다.

그림으로 이를 정리해보자면 아래와 같다.

| 클래스명 | 옥텟 | 시작        | 끝                  | 호스트 주소 개수 |
|----------|------|-------------|---------------------|------------------|
| 클래스 A | 0xxxxxxx | 0.0.0.0     | 127.255.255.255    | 16,777,214       |
| 클래스 B | 10xxxxxx | 128.0.0.0   | 191.255.255.255    | 65,534           |
| 클래스 C | 110xxxxx | 192.0.0.0   | 223.255.255.255    | 254              |
| 클래스 D | 1110xxxx | 224.0.0.0   | 239.255.255.255    | x                |

그러나, 이러한 클래스 방식을 이용하는 과정에서 클래스 방식의 한계로 인한 어려움에 직면하기 시작했다. 한 기관에서 어떤 클래스 방식으로 IP 주소를 할당한다고 해보자. 그러나 규모가 크지 않은 특성 탓에 사용하지 않는 수많은 IP들을 할당할 수 없게 되는, 이러한 비효율성이 불거지기 시작했다. 그래서 클래스로 나누지 말고, 다른 걸로 나누어서 IP를 할당하자는 방법론이 나왔으니, 그게 클래스리스 방식이다.

클래스리스 방식에서는 서브넷 마스크에 따라 네트워크 주소와 호스트 주소를 나누며, / 같은 표기를 통해 구분해서 IP를 할당하게 된다. 그러면 좀더 자세히 살펴보자.

클래스리스 방식의 핵심은 서브넷 마스크라 할 수 있는데, 그러면 서브넷 마스크란 무엇일까? 우리가 서브넷 마스크에 대해 알아보기 전에 서브넷에 대해 알 필요가 있을 거 같다. 서브넷이란 무엇일까? 책마다 각각 다르게 설명하지만, 핵심은 이와 같다.

> 이 세상에 복잡하고도 다양하게 얽혀있는 네트워크들을 가장 작은 논리적 단위로 쪼갠 것들 중 하나..

그렇다면, 그렇게 쪼개진 많은 네트워크들에 따라 생기게 되는 IP 주소들은 어떤 네트워크에 속해 있는지 등 각기 다른 IP 주소들 간 어떻게 구별될 수 있을까? 이전에는 위에서 설명했듯이 클래스별로 구분하여 IP 주소들을 나누고 할당하고 구별해왔지만, 클래스별로 구분하는 방식에 한계가 생기게 되면서 대안을 찾아야 했다. 그래서 나온 대안이 본 클래스리스 방식에서 핵심이라고 말했던 서브넷 마스크다. 

IP 주소는 네트워크 주소와 호스트 주소 두 개로 이루어져 있다고 하는데, 그 각기 다른 주소를 나누는 구분자가 서브넷 마스크로 2진수 숫자 1은 네트워크 주소, 0은 호스트 주소로 표시되어 사용된다. 보통, 우리가 보는 형태인 10진수로 표현된다면 아래와 같다.

> 255.0.0.0, 255.255.0.0, 255.255.255.0

이러한 서브넷 마스크를 이용해 네트워크 주소를 계산할 수 있는데, 이진수 and 계산을 이용해 IP 주소와 서브넷 마스크 만으로 네트워크 주소를 계산한다. 예를 들어보자.


예를 들어, 다음과 같은 IP 주소와 서브넷 마스크가 있다고 가정해보자:

> IP 주소 : 192.168.1.50 (이진 표기 : 11000000.10101000.00000001.00110010)<br>
서브넷 마스크 : 255.255.255.0 (이진 표기 : 11111111.11111111.11111111.00000000)

AND 연산을 사용하여 네트워크 주소를 계산하는 방법은 다음과 같다:


01) IP 주소와 서브넷 마스크를 이진으로 변환한다.

> IP 주소 : 11000000.10101000.00000001.00110010<br>
서브넷 마스크 : 11111111.11111111.11111111.00000000


02) 두 이진 수열을 AND 연산한다. 각 비트별로 AND 연산을 수행하면, 해당 비트가 모두 1일 때만 결과가 1이 된다.

> 11000000.10101000.00000001.00110010 (IP 주소)<br>
11111111.11111111.11111111.00000000 (서브넷 마스크)

결과: 11000000.10101000.00000001.00000000


03) AND 연산 결과를 다시 십진수로 변환한다. 이것이 네트워크 주소가 된다.

> 네트워크 주소 : 192.168.1.0

따라서, AND 연산을 사용하여 IP 주소와 서브넷 마스크를 비트 단위로 비교하여 네트워크 주소를 계산할 수 있다. 네트워크 주소는 네트워크의 일부를 나타내며, 호스트 주소는 나머지 부분을 나타낸다.

그러면, 이러한 서브넷 마스크는 어떻게 표현될까? 표현하는 방법으로는 비트 단위로 표현하는 방법과 10진수로 표현하는 방법 이렇게 2가지가 있다.

먼저, 비트 단위로 표현하는 방법부터 설명하자면, 위에서 잠깐 언급했듯이 "/" 이렇게 표기하는 방법인데, 서브넷 마스크에서 1부분이 연속된 자릿수를 표현해주는 것이다. A 클래스를 서브넷 마스크로 나타내면 첫번째 옥텟이 1, 나머지 옥텟이 0이므로 /8로 표현한다. B 클래스는 /16, C 클래스는 /24로 표기한다.

10진수로 표현하는 방법은 A 클래스는 255.0.0.0. B 클래스, C 클래스는 위에서 설명했던 대로 표기할 수 있다. 이 두가지 방법들 중 비트 단위로 표현하는 방법이 많이 쓰이는 것 같아서 알아두면 좋을 거 같다.

그러나, IPv4 주소가 이미 할당받은 대역을 제외하고는 고갈 상태이기 때문에 공인 IP 대역별 기본 서브넷 마스크를 쓸 수 없는 상황에 이르렀다. 이에 따라서 클래스별 기본 서브넷 마스크를 쓰지 않고 서브넷 마스크를 커스텀으로 변경하여 네트워크 부분을 늘리고 호스트 부분을 줄이는 조정을 하는 것을 서브네팅(Subnetting)이라고 한다. 이 부분은 추후에 다시 정리하는 것으로 하겠다.

---
**NAT**

이러한 원리에 의해 서로 다른 네트워크간 구별되고 할당되는 IP들은 사설이냐 공인이냐에 의해 또다시 나누어지게 된다. 이 과정에서 NAT 개념이 등장하게 되며, 포트포워딩이란 개념이 등장하는데 하나하나씩 살펴보겠다.

만약, 한 회사에서 어떤 웹 서비스를 배포한다고 가정해보자. 그러기 위해 우선 서버를 구비하였으니, 그 서버의 IP는 192.168.11.222이다. 그 IP에서 개발 환경을 데브옵스 엔지니어가 세팅하고, 그 환경 토대로 개발자들이 개발을 하였다. 여기서 이 서버의 ip인 192.168.11.22`2는 이 회사 건물의, 이 회사의 네트워크 하에서만 사용 가능하고 다른 네트워크에서는 사용할 수 없는 IP가 된다. 이렇게 특정 네트워크 내에서만 사용 가능한, 그 네트워크에서 특정 호스트의 IP를 사설 IP라고 한다.

이러한 사설 IP 형태로 이 회사 바깥 네트워크에 배포를 할 수 없다. 왜냐하면, 말했다시피 회사 내 네트워크 내에서만 사용 가능한 IP이기 때문에. 그렇다면 회사 바깥에서도, 전세계 어디에서도 개발자들이 192.168.11.222 서버 IP의 80 포트로 회사 내에서만 배포한 웹 서비스를 접속할 수 있도록 하려면 어떻게 해야 할까? 간단하다. 국제적으로 접속 가능한 IP로 매칭시켜서 접속 가능하도록 하면 되는 것이다. 이렇게 국제적으로 어디서든지 접속 가능한, 회사 바깥에서 접속 가능한 IP의 형태를 공인 IP라 하고. 이러한 공인 IP로 사설 IP를 매칭시키는 걸 NAT라고 한다. 정확한 설명은 아래와 같다.

>NAT는 내부 네트워크에서 사용되는 사설 IP 주소를 외부 네트워크에서 접근 가능한 공인 IP 주소로 변환하는 프로세스를 의미한다. 이를 통해 여러 내부 디바이스가 하나의 공인 IP 주소를 공유하며 외부 인터넷과 통신할 수 있게 된다.

그리고 또한, 이때 공인 IP의 특정 포트에서 내부 IP의 특정 포트의 서비스로 접속 가능하도록 하는 걸 포트 포워딩이라고 부른다. 이러한 내용을 아래 구성도를 통해 이해해보자.

![Desktop View](/assets/img/network/ip/portforwarding_diagram.png){: width="972" height="589"}

1. "내부 서비스"는 사설 IP 주소 192.168.1.100과 포트 80을 사용하여 실행 중인 개인 네트워크 내의 웹 서비스를 나타낸다.
2. "내부 서비스"는 "example.com" 도메인과 "203.0.113.1"라는 공인 IP 주소로 연결되며, 라우터 또는 방화벽을 통해 "192.168.1.100" 내부 서비스 IP로 포트 포워딩된다.
3. "외부 서비스"는 "example.com" 도메인과 "203.0.113.1" 공인 IP 주소 및 포트 80을 사용하여 "내부 서비스"에 엑세스할 수 있다.

실제로 사용할 때에는 도메인과 IP 주소를 해당 서비스 제공 업체 또는 도메인 등록 업체에서 설정하고, 라우터 또는 방화벽에서 포트 포워딩을 구성해야 한다. 물론 80이나 443 포트로 서비스 배포를 위해선 웹서비 설정도 필요한데, 이건 나중에 따로 정리하는 걸로 하자.


여기까지가 IP 주소와 서브넷에 대한 내용이었다. IP 개념은 상당히 방대하고도 어려운 개념이라 이 포스팅만으로 다 내용을 담지 못했으며, 잘못되었을 수 있다. 이 부분은 다시 보완해나가면서 채워나가기로 한다. 