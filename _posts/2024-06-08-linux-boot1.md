---
title: 리눅스 부트1
author: 노아
date: 2024-06-08 21:59:00 +0800
categories: [Linux, 리눅스 부트1]
tags: [리눅스, 부트, 부팅]
pin: true
math: true
mermaid: true

---
리눅스 부트

# 목차

- 부트 매니저
- 리눅스 부팅 과정

이 부분에 대해 알아보기 위해 여러 자료들을 살펴보았으나 이해하는데 어려움이 있었다. 그리고 그 과정에서 파생되는 여러 개념들이 등장하여 어디서부터 어디까지 이해해야 할지에 대한 막막함도 있었다. 그럼에도 나름대로 정리는 한다고 했지만, 이 포스팅 부분은 조금 더 공부를 해야 할 필요성을 느낄 수 있었다. 그래서, 해당 포스팅에서는 간단히 개념을 소개하는 선에서 정리하는 것으로 하고. 이후 다시 공부할 때 다시 구체적으로 알아보기로 한다. 또한, 리눅스 부트 포스팅은 1,2에 걸쳐서 정리를 하고자 한다. 이 점 참조 바란다.

# 부트 매니저(Boot Manager)

부트 매니저란, 리눅스 설치 또는 부팅시 여러 운영 체제 중 하나를 선택할 수 있도록 해주는 프로그램으로 GRUB과 Systemd-boot가 있다. 

>이때, GRUB은 부트 로드에서도 등장하는데, 이 이유는 GRUB이 부트 매니저의 역할과 부트 로더로서의 역할을 동시에 할 수 있기 때문이다. 부트 매니저로서의 GRUB은 여러 운영 체제를 선택할 수 있는 메뉴를 제공하며, 부트로더로서의 GRUB은 선택된 운영 체제의 커널을 메모리에 로드하고 실행한다. 이 점 참조 바란다.

* 주요 개념 소개
><b>커널(Kernel)</b>은 운영 체제의 핵심 구성 요소로, 하드웨어와 소프트웨어 간의 중재 역할을 한다. 즉, 리눅스 서버의 두뇌 역할을 한다고 할 수 있으며, 이를 통해 시스템 자원을 효율적으로 관리할 수 있다. 이는 즉, 물리적인 실체인 하드웨어 장비 하드 디스크 등에 대해 리눅스 서버라는 어떻게 보면 추상적인 존재를 통해 접근 및 통제 가능하도록 하드웨어 장비와 리눅스 서버간 그 중간 가교 역할을 커널이 한다라고 할 수 있다는 말이다. 그래서 이러한 커널의 특성 때문에 응용 프로그램과 사용자는 하드웨어의 복잡한 세부 사항을 알 필요 없이 시스템을 사용할 수 있는데, 이러한 커널의 역할로는 아래 6가지가 있다.
>
> 1. 프로세스 관리
> 2. 메모리 관리
> 3. 파일 시스템 관리
> 4. 네트워킹
> 5. 장치 드라이버 관리
> 6. 보안 및 권한 관리
> 
> 위 각각에 대한 자세한 내용은 이 포스팅에서는 다루지 않기로 하며, 나중에 디테일하게 이해할 수 있을때 그때 다시 정리하기로 한다. 
>
>
><b>BIOS (Basic Input/Output System)</b><br>
> <b>BIOS</b>는 컴퓨터 시스템 초기화 및 기본 입출력을 관리하는 펌웨어이다. 주요 특징은 아래와 같다.<br>
> 역사적 배경 : BIOS는 초기 PC 시대부터 사용되었으며, 초기 IBM PC에서부터 Intel 기반 시스템에서 널리 사용됨.<br>
> 기능 : 주로 하드웨어 초기화, 부팅 장치 선택, 시스템 설정 관리 등의 기능을 수행함.<br>
> 제한적인 기능 : 전통적인 BIOS는 부팅 디스크의 MBR (Master Boot Record)을 통해 부팅 프로세스를 관리하며, 한번에 하나의 부팅 로더만을 지원할 수 있음.<br>
>
><b>UEFI (Unified Extensible Firmware Interface)</b><br>
><b>UEFI</b>는 BIOS의 한계를 극복하고 더 많은 기능과 유연성을 제공하기 위해 개발된 시스템 펌웨어로, 주요 특징은 아래와 같다.<br>
> 역사적 배경 : UEFI는 2000년대 초반에 개발되어 기존 BIOS의 한계를 극복하고자 함.<br>
> 기능 : 보다 진보된 그래픽 인터페이스, 네트워크 부팅 지원, 대용량 디스크의 GPT (GUID Partition Table) 지원 등 다양한 기능을 제공.<br>
> 확장성 : UEFI는 플러그인 형식의 확장 가능한 애플리케이션을 지원하며, 보안 기능도 강화됨.<br>
> 부팅 방식 : UEFI는 EFI 시스템 파티션에 위치한 부팅 로더를 통해 부팅을 관리하며, 여러 개의 부팅 옵션을 동시에 관리할 수 있음.<br>
>
> 즉, BIOS와 UEFI는 컴퓨터 초기 부팅 과정을 제어하는 시스템 펌웨어라는 점에서 공통점이 있으나, BIOS는 오래된 기술로 제한적인 기능을 가지고 있는 반면, UEFI는 더 많은 기능과 보안성을 제공한다. 그래서 현대 컴퓨터 시스템은 대부분 UEFI를 사용하며, UEFI를 통해 더욱 유연하고 고급화된 부팅 및 시스템 관리 기능을 활용할 수 있다.
>
><b>MBR(마스터 부트 레코드, Master Boot Record)</b><br>
> <b>MBR</b>은 하드 디스크 또는 기타 저장 장치의 첫 번째 섹터에 위치한 특별한 부트 섹터로, 하드 디스크의 첫 번째 섹터에 위치하며, 부팅 프로세스를 시작하고 파티션 정보를 관리하는 512바이트 크기의 섹터이다. 최대 4개의 주 파티션을 지원하며, 2TB 크기 제한이 있다.


# 리눅스 부팅 과정

리눅스 부팅 과정 설명을 위해 먼저 전체적인 개요부터 표로 보여준 다음에, 각각의 단계에 대한 설명을 하는 것으로 진행하겠다. 먼저, 리눅스 부팅 과정에 대해 전체적인 내용을 간단히 요약해보자면, 아래와 같다.

| 단계 | 진행 과정 | 설명 |
| 1단계 | ROM-BIOS 실행 | - POST(Power On Self Test) 과정을 수행 후 하드웨어 이상 유무를 검사한 후 에러가 발생할 경우 알림<br> - 부트 로더 로딩 |
| 2단계 | 부트 로더 실행 | - 부트 로더를 실행하여 커널을 로딩하고, 스와퍼 프로세스 호출<br> - LILO와 GRUB가 있음 |
| 3단계 | 스와퍼 프로세스 실행 | - 장치들의 드라이버 초기화<br> - init 프로세스 실행 |
| 4단계 | init 프로세스 실행 | init 프로세스를 실행하여 /etc/inittab 파일 읽음 |
| 5단계 | 부트 레벨 결정 | 부트 레벨을 결정 |
| 6단계 | rc.sysinit 스크립트 실행 | /etc/rc.d/rc.sysinit 스크립트를 실행하여 시스템 초기화 작업 수행 |
| 7단계 | rcx.d 스크립트 실행 | /etc/rcx.d 스크립트를 실행하여 해당 부트 레벨 스크립트를 순차적으로 실행 |
| 8단계 | X 윈도 실행 | 부트 레벨이 5일 경우 X 윈도 환경으로 부팅 |

그러면 각각에 대해 설명을 진행해보겠다. 

<b>1단계, ROM-BIOS 실행</b>

컴퓨터 전원이 켜지고 나면 가장 먼저 실행되는 프로그램이 ROM-BIOS이다. 그렇다면 이 ROM-BIOS는 무엇인지 알아보기로 하자.

>정의 및 소개<br>
<b>ROM-BIOS</b>란 컴퓨터 시스템에서 중요한 역할을 하는 펌웨어이다. "ROM"은 Read-Only Memory(읽기 전용 메모리)를 의미하고, "BIOS"는 Basic Input/Output System(기본 입출력 시스템)을 의미한다. ROM-BIOS는 컴퓨터의 하드웨어 초기화, 운영체제 부팅, 하드웨어와 소프트웨어 간의 인터페이스 제공 등의 역할을 한다. 다음은 ROM-BIOS의 구성 요소와 작동 원리에 대해 자세히 설명한 내용이다.

```
ROM (Read-Only Memory)
- 비휘발성 메모리
  - 전원이 꺼져도 데이터가 지워지지 않는다.
  - 읽기 전용으로, 데이터는 제조 과정에서 쓰여지고 일반 사용자가 수정할 수 없다.
  - 컴퓨터의 기본적인 펌웨어, 즉 BIOS가 저장되어 있다.
- 영구적 저장
  - BIOS 프로그램이 ROM에 저장되어 있기 때문에 컴퓨터가 꺼져도 BIOS는 유지된다.
  - 이로 인해 컴퓨터가 켜질 때마다 BIOS가 실행될 수 있다.

BIOS (Basic Input/Output System)
- 펌웨어
  - 컴퓨터의 하드웨어를 초기화하고, 운영체제가 로드되기 전에 하드웨어를 제어하는 저수준 소프트웨어.
  - BIOS는 ROM에 저장된 프로그램으로, 컴퓨터가 켜질 때마다 자동으로 실행된다.
- 하드웨어 초기화
  - 전원이 켜질 때 BIOS는 POST(Power-On Self Test)를 수행하여 시스템의 주요 하드웨어가 정상적으로 작동하는지 확인한다.
  - POST 과정에서는 메모리, 키보드, 하드 드라이브, 그래픽 카드 등 여러 하드웨어 구성 요소들이 점검된다.
  - 하드웨어 초기화는 CMOS에 저장된 설정 정보를 참조하여 이루어진다.
- 부트 로더
  - 하드웨어 초기화가 완료되면, BIOS는 CMOS에 저장된 부팅 순서 정보를 사용하여 부팅 장치를 선택한다.
  - 선택된 장치에서 부트 로더를 실행하여 운영체제를 메모리에 로드하고 실행한다. 
  - 부트 로더는 운영체제를 메모리에 로드하고, 제어를 운영체제에 넘긴다.
- 하드웨어 인터페이스
  - BIOS는 운영체제와 하드웨어 간의 기본적인 인터페이스 역할을 한다.
  - 운영체제가 하드웨어 자원에 접근할 수 있도록 기본적인 입출력 기능을 제공한다.
  - 예를 들어, 키보드 입력, 디스크 읽기/쓰기 등의 저수준 명령을 처리한다.

CMOS와의 관계
- CMOS 메모리
  - CMOS(Complementary Metal-Oxide-Semiconductor)는 BIOS 설정 정보를 저장하는 작은 메모리.
  - CMOS 메모리는 시스템 시계, 부팅 순서, 하드웨어 설정 정보 등을 저장.
  - CMOS는 전원이 꺼져도 데이터를 유지하기 위해 작은 배터리 사용.
- BIOS 설정 저장
  - 사용자가 BIOS 설정 화면에서 변경한 모든 설정은 CMOS에 저장된다.
  - 다음 번 컴퓨터가 켜질 때 BIOS는 CMOS에 저장된 설정을 사용하여 시스템을 초기화하고 부팅한다.

자동 실행 과정
- 1. 전원 공급
  - 컴퓨터의 전원이 켜지면, 전원 공급 장치(PSU)가 전력을 공급하고, CPU가 초기화된다.
  - CPU는 하드웨어적으로 지정된 위치에서 ROM에 저장된 BIOS 코드를 실행한다.
- 2. POST 및 하드웨어 초기화
  - BIOS는 POST를 수행하여 시스템의 주요 하드웨어가 정상적으로 동작하는지 확인한다.
  - POST가 완료되면 BIOS는 하드웨어 초기화를 수행하고, CMOS에 저장된 설정을 참조한다.
- 3. 부팅 장치 선택 및 운영체제 로드
  - BIOS는 CMOS에 저장된 부팅 순서 정보를 사용하여 부팅 장치를 선택한다.
  - 선택된 부팅 장치에서 부트 로더를 실행하여 운영체제를 메모리에 로드하고, 이를 실행한다.
```

>결론<br>
- ROM-BIOS는 컴퓨터가 전원이 켜질 때 자동으로 실행되어 시스템을 초기화하고 부팅하는 중요한 역할을 한다. BIOS는 ROM에 저장된 펌웨어로, 하드웨어 초기화, 부팅 장치 선택, 부트 로더 실행, 하드웨어와 운영체제 간의 인터페이스 제공 등의 기능을 수행한다. CMOS는 BIOS 설정 정보를 저장하며, BIOS는 컴퓨터가 켜질 때 CMOS에 저장된 설정을 사용하여 시스템을 초기화하고 부팅한다. 이로 인해 BIOS는 컴퓨터가 전원이 켜질 때마다 자동으로 실행되어 시스템이 정상적으로 운영체제를 로드하고 실행할 수 있도록 한다.

아래는 ROM-BIOS에 대한 참조 사진이다.

![Desktop View](/assets/img/linux/boot/linux_boot1.png){: width="972" height="589"}
출처 : [사이트 url](https://www.linux.co.kr/bbs/board.php?bo_table=lecture&wr_id=4427)
![Desktop View](/assets/img/linux/boot/linux_boot2.jpg){: width="972" height="589"}
출처 : [사이트 url](https://www.linux.co.kr/bbs/board.php?bo_table=lecture&wr_id=4427)

이렇게 ROM-BIOS에 대해 알아보았는데, 모두 기억할 필요는 없고, 이해를 위한 참조 정도로만 생각하고 넘어가자. 다만, 이러한 ROM-BIOS의 역할은 중요하므로, 기억해두기로 한다. ROM-BIOS는 아래 두가지 역할을 한다.

- 1. POST 기능, 하드웨어의 각 장치들 인식 및 초기화(자체 진단 가능)
- 2. 부트로더 로딩 기능

먼저, POST 기능에 대해 알아보자. 메인보드에 있는 ROM-BIOS의 BIOS 프로그램들은 시스템에 장착된 하드웨어 장치들을 하나씩 인식하기 시작한다. 이때 하드웨어(CPU, RAM, DISK 등)들을 인식하고 이상유무를 체크한 후에 이상이 없다면 각 장치가 사용될 수 있도록 모든 장치의 초기화를 수행한다.

만약 각 장치를 인식하는 단계에서 이상이 발생한다면 "빽! 삑!"하는 에러음을 내면서 부팅이 멈추게 된다. 그리고 이 에러음의 개수와 음종류에 따라서 어떤 장치에서 에러가 발생하였는가를 알 수 있다.

그리고 컴퓨터의 시리얼장치, 패러럴장치 등이 이 단계에서 ROM-BIOS 프로그램에 의해 모두 인식되고 또한 사용을 위한 초기화가 수행된다. 이것이 전원이 들어왔을때에 ROM-BIOS가 하는 가장 첫번째 역할은 자체 진단 기능인 POST(Power On Self Test)이다.


두번째 기능은 부트로더를 로딩하는 기능이다.

이 두번째 기능은 시스템 부팅 기능으로서 POST 과정이 아무런 이상없이 수행 완료 되었을 때 부트로더를 메모리로 로딩하여 리눅스 부팅을 시작하는 역할이다. ROM-BIOS는 이미 앞에서 컴퓨터에 장착된 각 장치들을 모두 인식하였다. 따라서 현재 운영체제가 저장되어있는 장치 또한 인식되어있다. 이말은 즉, ROM-BIOS가 부트로더를 가지고 있는 부팅매체(하드디스크, CD-ROM, USB, 플로피 등)를 하나씩 검사하기 시작한다는 걸 의미한다. 그래서 여기서 가장 먼저 검색된 하드 디스크 장치에서 부트 로더를 불러들이게 된다.

이렇게 해서 검색된 부팅 매체(ex. 하드 디스크, CD-ROM 등)의 0번 섹터(MBR)에서 Boot Program을 읽어들여 메모리로 적재한다. 이 Boot Program을 부트로더라고 하기도 하고, Boot Sector라고 부르기도 한다. 중요한 것은 이 Boot Program에 리눅스의 부트 로더인 GRUB이 들어있다는 것이다. 

따라서, GRUB이 메모리에 로딩되어 실행되면서부터는 시스템의 모든 제어권은 GRUB이 가지게 되어 이후 부팅 과정을 주도하게 된다는 것이다.


<b>2단계, 부트로더 실행</b>

이전까지 우리는 컴퓨터 전원이 켜지면서 ROM-BIOS에 의해 수행되는 역할들을 크게 2가지로 나누어서 배웠다. 그 역할들 가운데 가장 마지막 역할이 리눅스 부트로더인 GRUB의 실행이다. GRUB이 실행되었을때 우리는 다음과 같은 화면을 컴퓨터에서 보게 된다.

![Desktop View](/assets/img/linux/boot/linux_bootloader.png){: width="972" height="589"}
출처 : 위키백과

바로 이 시점이 부팅 과정의 초기 단계에서 우리가 늘 보아왔던 GRUB의 부팅 초기화면이다. 이 단계에서 우리는 원하는 부팅 메뉴를 선택하여 원하는 커널로 부팅할 수 있는 것이다. 

GRUB이 실행되었다면 이 GRUB은 어떤 역할을 수행하게 될까? GRUB의 역할 또한 다음과 같이 크게 2가지로 나누어볼 수 있다.

- 1. 리눅스 커널 적재
- 2. 스와퍼(Swapper) 프로세스 호출

이것이 GRUB이 하는 가장 큰 2가지 역할이다. 위의 화면에서 어떤 부팅 메뉴로 부팅을 할 것인가를 결정하는 것은 /boot/grub/grub.conf 파일에 정의되어있다. 즉, 이 파일의 내용에 따라서 위의 화면에 나오는 메뉴들이 달라진다는 의미이다.

다음은 /boot/grub/grub.conf 파일의 내용이다.

```
[root@~~ ~]#cat /boot/grub/grub.conf
default=0
timeout=5
splashimage=(hd0,0)/grub/splash.xpm.gz
hiddenmenu
password --md5 $1$w/FxeJ6H$EjTg1ecIOxYb4HOj1UBpR1
title SULinux Server 2.0 (2.6.18-92.SUL2.fd)
        root (hd0,0)
        kernel /vmlinuz-2.6.18-92.SUL2.fd ro root=LABEL=/ rhgb quiet vga=771
        initrd /initrd-2.6.18-92.SUL2.fd.img
```

앞에서 보았던 GRUB 실행 화면에서 우리는 어떤 커널로 로딩할 것인가를 선택할 수 있었다. 이것이 GRUB의 첫번째 기능인 리눅스 커널 로딩 기능이다.

> <b>참조</b><br>
> Ubuntu에서는 GRUB 2를 사용하기 때문에 위 설명 기준인 GRUB1(legacy GRUB)과는 구성 파일의 위치와 구조가 다르다. 아래는 그 차이점을 나타낸 것이다.<br>
> 
> <b>GRUB1과 GRUB2 간 차이점</b><br>
> - 1. 구성 파일 위치
>   - GRUB1 : 구성 파일은 /boot/grub/grub.conf 또는 /boot/grub/menu.lst에 있다.
>   - GRUB2 : 구성 파일은 /boot/grub/grub.cfg에 있다.
> 
> - 2. 구성 파일 구조
>   - GRUB1 : 단일 구성 파일인 grub.conf 또는 menu.lst에 모든 부팅 항목이 정의된다.
>   - GRUB2 : 여러 구성 파일로 나뉘며, /etc/grub.d/ 디렉터리 내의 스크립트와 /etc/default/grub 파일을 사용하여 grub.cfg 파일이 생성된다.

리눅스 커널이 메모리에 적재되는 순간부터 본격적인 부팅이 시작된다. 여기서 선택한 리눅스 커널 메뉴(부팅메뉴라고도 한다)로 GRUB은 부팅을 계속 해나간다. 즉, GRUB은 /boot/grub/grub.conf 파일에 정의되어있는 여러가지 리눅스 커널 중 선택된 리눅스 커널을 메모리에 로딩한다. 이것이 리눅스 커널의 로딩이고 GRUB이 하는 첫번째 중요한 역할이다.

리눅스 커널 로딩이 끝난 후에 수행하는 GRUB의 두번째 역할은 스와퍼(Swapper)라는 좀 생소한 프로세스 실행이다. 


<b>3단계, 스와퍼(Swapper) 프로세스 실행</b>

Grub에 의해 실행된 스와퍼(Swapper)라는 프로세스의 첫번째 역할은 앞단계에서 인식했던 각 장치들의 드라이브들을 초기화하는 것이다. 즉, GRUB에 의해 실행된 스와퍼라는 PID 0번인 프로세스는 각 장치 드라이브들을 초기화하고 그 다음 PID 1번인 init 프로세스를 실행한 후에 스스로 종료한다. 

정리하자면, 스와퍼라는 프로세스는 부팅시에 잠시 실행되었다가 사라지므로 부팅이 완료되고 난 이후에는 존재하지 않는 프로세스인 것이다.


<b>4단계, init 프로세스 실행</b>

스와퍼 프로세스에 의해 init이라는 프로세스가 실행된다. 모든 프로세스는 그 실행과 함께 설정 파일을 읽어들인다. init 프로세스 또한 /etc/inittab이라는 설정 파일을 읽어들여 무엇을, 어떻게, 언제 실행할 것인가를 결정한다. /etc/inittab 파일에 init 프로세스에서 실행될 내용이 모두 정의되어 있는데, 부팅 과정에서 화면으로 출력되는 거의 모든 부팅 메세지들이 init 프로세스에 의해서 실행되는 /etc/inittab 파일의 실행 내용이다. 말하자면, 이후부터의 모든 부팅 과정은 /etc/inittab 파일의 내용들이 순차적으로 실행되는 것이다.

><b>참조</b><br>
> Ubuntu에 /etc/inittab 파일이 없는데, 그 이유는 Ubuntu가 전통적인 SysVinit 초기화 시스템 대신 Upstart(이전 버전)와 systemd(현재 버전)를 사용하기 때문이다. systemd는 unit 파일을 사용하여 서비스를 관리하며, /etc/inittab 파일을 사용하지 않는다. systemd의 구성 파일은 주로 /etc/systemd 디렉터리에 위치하며, systemctl 명령어를 통해 서비스 관리를 할 수 있다. 


<b>5단계, 부트 레벨 결정</b>

부트 레벨(boot level)은 컴퓨터 운영 체제에서 시스템이 시작될 때 실행되는 초기화 및 설정 단계를 의미. 이 용어는 주로 UNIX 계열 운영 체제에서 사용되며, 각 부트 레벨은 시스템의 상태를 정의. 부트 레벨은 특정 작업을 수행하거나 시스템의 특정 상태로 전환하기 위해 설정됨. 또한, 시스템의 시작 또는 재부팅 시 특정 설정 스크립트를 통해 설정되는데, 예를 들어 리눅스 시스템에서는 /etc/inittab 파일이나 systemd 설정을 통해 부트 레벨을 관리할 수 있다. 다음은 일반적으로 사용되는 부트 레벨이다.

- 1. 부트 레벨 0 : 시스템 종료(halt). 이 레벨은 시스템을 완전히 종료하는데 사용된다.
- 2. 부트 레벨 1 : 단일 사용자 모드(single-user mode). 시스템 관리자만 접근할 수 있으며, 시스템 유지보수 작업을 수행할 때 사용됨. 네트워크는 활성화되지 않음.
- 3. 부트 레벨 2 : 다중 사용자 모드(multi-user mode) 없이 네트워크 서비스가 활성화되지 않음.
- 4. 부트 레벨 3 : 다중 사용자 모드(multi-user mode) 및 네트워크 서비스가 활성화됨. 이 레벨은 일반적으로 텍스트 기반 서버 모드.
- 5. 부트 레벨 4 : 사용되지 않거나 사용자 정의 용도로 예약됨.
- 6. 부트 레벨 5 : 다중 사용자 모드 및 네트워크 서비스가 활성화됨. GUI(Graphical User Interface)를 포함한 완전한 사용자 환경을 제공함.
- 7. 부트 레벨 6 : 시스템 재부팅(reboot). 이 레벨은 시스템을 재시작하는데 사용됨.

아래는 일반적인 /etc/inittab의 예시이다.

```
# /etc/inittab: init(8) configuration.
# This file describes how the INIT process should set up
# the system in a certain run-level.

# Default runlevel. The runlevels used by RHS are:
#   0 - halt (Do NOT set initdefault to this)
#   1 - Single user mode
#   2 - Multiuser, without NFS (The same as 3, if you do not have networking)
#   3 - Full multiuser mode
#   4 - unused
#   5 - X11
#   6 - reboot (Do NOT set initdefault to this)
#
id:3:initdefault:

# System initialization.
si::sysinit:/etc/rc.d/rc.sysinit

# What to do in single-user mode.
~~:S:wait:/sbin/sulogin

# Run gettys in standard runlevels
1:2345:respawn:/sbin/mingetty tty1
2:2345:respawn:/sbin/mingetty tty2
3:2345:respawn:/sbin/mingetty tty3
4:2345:respawn:/sbin/mingetty tty4
5:2345:respawn:/sbin/mingetty tty5
6:2345:respawn:/sbin/mingetty tty6

# Run xdm in runlevel 5
x:5:respawn:/etc/X11/prefdm -nodaemon
```

위에서 아래 내용은 기본 런레벨을 3으로 설정해서, 시스템이 부팅될 때 자동으로 런레벨 3으로 시작된다는 것이다.

```
id:3:initdefault:
```


<b>6단계, rc.sysinit 스크립트 실행</b>

앞 단계에서 시스템 부팅 레벨이 3번 부팅 레벨로 결정되었다면, 이번에는 그 다음 행 설정 내용에 의해 rc.sysinit 스크립트 파일이 실행되는 것이다. 위 파일 /etc/inittab에서 보자면 아래 부분이다.

```
# System initialization.
si::sysinit:/etc/rc.d/rc.sysinit
```

위 주석문의 내용처럼 /etc/rc.d/rc.sysinit 스크립트 파일은 "시스템 초기화" 작업을 수행하는 스크립트이다. 즉, 부팅 레벨이 몇 번인지와 관계없이 모든 부팅 레벨로 시스템이 부팅되면 꼭 한번 실행되는 스크립트라고 보면 된다. 


<b>7단계, rcx.d 스크립트 실행</b>

이전 단계에서 시스템 초기화 스크립트가 실행되었다. 그렇다면, 그 다음에 init 프로세스는 /etc/inittab 파일에 정의된 대로 특정 런레벨로 전환한다. 특정 런레벨로 전환될 때 해당 런레벨에 해당하는 /etc/rcX.d 디렉터리의 스크립트를 실행한다. /etc/rcX.d 디렉터리는 UNIX 및 Linux 시스템에서 system v init(init.d) 시스템을 사용하는 경우 런레벨에 따라 실행할 스크립트를 관리하는데 사용된다. 이때 /etc/rcXd.에서 X는 런레벨을 나타내는 숫자(0-6)이다. 이러한 각 rcX.d 디렉터리에는 시작('S#name') 및 종료('K##name') 스크립트가 포함되어 있으며, 숫자('##')에 따라 실행 순서가 결정된다. 런레벨 개요와 디렉터리 구조, 스크립트 실행 순서를 정리하자면 아래와 같다.

- 런레벨 개요
  - 0 : 시스템 종료(halt)
  - 1 : 단일 사용자 모드(single-user mode)
  - 2 : 다중 사용자 모드, 네트워크 비활성화
  - 3 : 다중 사용자 모드, 네트워크 활성화(일반적으로 텍스트 모드)
  - 4 : 사용자 정의 가능 (unused/user-definable)
  - 5 : 다중 사용자 모드, 네트워크 및 GUI 활성화(X11)
  - 6 : 시스템 재부팅(reboot)

- 디렉터리 구조
  - /etc/rc0.d : 런레벨 0(시스템 종료)로 전환될 때 실행할 스크립트
  - /etc/rc1.d : 런레벨 1(단일 사용자 모드)로 전환될 때 실행할 스크립트
  - /etc/rc2.d : 런레벨 2(다중 사용자 모드, 네트워크 비활성화)로 전환될 때 실행할 스크립트
  - ...

- 스크립트 실행 순서
  - 각 디렉터리에는 다음과 같은 형식의 심볼릭 링크가 포함된다.
    - K##name : 런레벨로 전환될 때 서비스를 종료하는 스크립트
    - S##name : 런레벨로 전환될 때 서비스를 시작하는 스크립트

    여기서 ##는 두자리 숫자(00-99)로, 스크립트의 실행 순서를 결정한다. 작은 숫자가 먼저 실행된다.

    예를 들어 /etc/rc3.d 디렉터리에 다음과 같은 내용이 있다고 해보자.

    ```
    K20nfs -> ../init.d/nfs
    K30httpd -> ../init.d/httpd
    S10network -> ../init.d/network
    S20sshd -> ../init.d/sshd
    ```

    위 예시는 network 서비스가 먼저 시작되고(S10network), 그 다음으로 sshd 서비스가 시작된다(S20sshd). nfs와 httpd 서비스는 각각 K20nfs와 K30httpd로 표시된 순서대로 종료된다.


<b>8단계, X 윈도 실행</b>

해당 단계는 부팅 레벨이 5번일 경우에 실행되는 단계로, 가상 터미널에서 텍스트 로그인 창을 띄우고 있는 그 장면이 바로 로그인 과정의 마지막이다. 하지만 부팅 레벨이 5번이라면 다음 마지막 행이 추가로 실행된다. 즉, GUI 사용자 환경을 제공하기 위한 X 윈도우를 실행하는 것이다. 다음 내용은 /etc/inittab 파일의 마지막 실행 내용으로서 부팅 레벨 5번일 경우에 X 윈도우를 실행하는 설정행이다.

```
x:5:respawn:/etc/X11/prefdm -nodaemon
```

위의 설정 내용을 보면, /etc/X11/prefdm이 실행된다는 것인데, prefdm 파일은 x윈도우를 실행시켜주는 스크립트 파일이다. 해당 스크립트가 실행되면 x 윈도우가 시행됨으로써 X 윈도우 로그인 화면을 띄우고 모든 부팅 과정이 끝나게 되는 것이다.





